/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all2) => {
  __markAsModule(target);
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  DEFAULT_DATA: () => DEFAULT_DATA,
  default: () => QuothPlugin
});
var import_obsidian10 = __toModule(require("obsidian"));

// src/addIcons.ts
var import_obsidian = __toModule(require("obsidian"));
function addIcons() {
  (0, import_obsidian.addIcon)("quoth-copy", `<path d="M11.718,98.539C11.829,98.65 73.298,98.534 73.298,98.534L73.298,88.013L68.867,88.013L68.867,94.104L15.705,94.109L15.705,18.791L23.901,18.791L23.901,14.361L11.275,14.361L11.718,98.539ZM65.245,1.413L26.702,1.413L26.702,85.586L88.725,85.586L88.725,24.893L88.282,24.45C88.171,24.339 88.06,24.117 87.839,24.007L66.131,2.188C66.02,2.077 65.91,1.856 65.688,1.745L65.245,1.413ZM31.133,5.843L62.144,5.843L62.144,27.994L84.295,27.994L84.295,81.156L31.133,81.156L31.133,5.843ZM45.596,36.647C44.25,36.647 43.158,37.738 43.158,39.085L43.158,48.801C43.158,50.147 44.25,51.239 45.596,51.239L50.509,51.239C50.545,53.422 50.327,58.044 48.216,61.501C47.889,62.01 47.961,62.629 48.398,63.029C48.835,63.429 49.49,63.466 49.963,63.102C49.963,63.102 55.312,59.026 55.312,51.202L55.312,39.085C55.312,37.738 54.22,36.647 52.874,36.647L45.596,36.647ZM62.553,36.647C61.207,36.647 60.115,37.738 60.115,39.085L60.115,48.801C60.115,50.147 61.207,51.239 62.553,51.239L67.466,51.239C67.502,53.422 67.284,58.044 65.173,61.501C64.846,62.01 64.919,62.629 65.355,63.029C65.792,63.429 66.447,63.466 66.92,63.102C66.92,63.102 72.269,59.026 72.269,51.202L72.269,39.085C72.269,37.738 71.178,36.647 69.831,36.647L62.553,36.647ZM66.574,8.944L81.194,23.564L66.574,23.564L66.574,8.944Z" style="fill-rule:nonzero;" fill="currentColor" stroke="currentColor" />`);
}

// src/commands/buildEmbed.ts
var import_obsidian2 = __toModule(require("obsidian"));

// src/util/stringSearch.ts
function indexOfLine(text, line) {
  let idx = -1;
  for (let newLines = 0; newLines < line; newLines++) {
    if ((idx = text.indexOf("\n", idx + 1)) < 0) {
      return -1;
    }
  }
  return idx + 1;
}
function indexPos(text, index) {
  const lines = text.slice(0, index).split("\n");
  return { line: lines.length - 1, ch: lines.last().length };
}
function uniqueStrRange(text, search) {
  let startLen = Math.min(search.length, 10);
  while (!isUnique(text, search.slice(0, startLen))) {
    startLen += 1;
  }
  let endLen = Math.min(search.length, 10);
  while (!isUnique(text, search.slice(-endLen))) {
    endLen += 1;
  }
  if (startLen + endLen > search.length) {
    return [search];
  }
  return [search.slice(0, startLen), search.slice(-endLen)];
}
function isUnique(text, search) {
  const idx = text.indexOf(search);
  return idx >= 0 && text.indexOf(search, idx + 1) === -1;
}

// src/model/range.ts
var PosRange = class {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  indexes(doc) {
    const start = posIndex(doc, this.start);
    const end = posIndex(doc, this.end);
    return { start, end };
  }
  toString() {
    return `${posString(this.start)} to ${posString(this.end)}`;
  }
};
var StringRange = class {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
  indexes(doc) {
    const start = stringIndex(doc, this.start);
    const end = stringIndex(doc, this.end, start) + this.end.length;
    return { start, end };
  }
  toString() {
    return `${JSON.stringify(this.start)} to ${JSON.stringify(this.end)}`;
  }
};
var WholeString = class {
  constructor(str) {
    this.str = str;
  }
  indexes(doc) {
    const start = stringIndex(doc, this.str);
    const end = start + this.str.length;
    return { start, end };
  }
  toString() {
    return JSON.stringify(this.str);
  }
};
var AfterString = class {
  constructor(str) {
    this.str = str;
  }
  indexes(doc) {
    const start = stringIndex(doc, this.str) + this.str.length;
    const end = doc.length;
    return { start, end };
  }
  toString() {
    return `after ${JSON.stringify(this.str)}`;
  }
};
var AfterPos = class {
  constructor(pos) {
    this.pos = pos;
  }
  indexes(doc) {
    const start = posIndex(doc, this.pos);
    const end = doc.length;
    return { start, end };
  }
  toString() {
    return `after ${posString(this.pos)}`;
  }
};
function posString(p) {
  return `${p.line}:${p.ch}`;
}
function stringIndex(doc, search, after) {
  const index = doc.indexOf(search, after);
  if (index === -1) {
    throw new Error(`Could not find ${JSON.stringify(this.str)} in file`);
  }
  return index;
}
function posIndex(doc, pos) {
  const lineIndex = indexOfLine(doc, pos.line);
  if (lineIndex === -1 || lineIndex + pos.ch > doc.length) {
    throw new Error(`${posString(pos)} is out of bounds`);
  }
  return lineIndex + pos.ch;
}

// src/model/embed.ts
var DEFAULT_JOIN = " ... ";
var DEFAULT_DISPLAY = "embedded";
function serialize(embed) {
  let ref = "```quoth\n";
  ref += `path: [[${embed.file}${embed.subpath}]]
`;
  if (embed.ranges.length > 0) {
    ref += `ranges: ${embed.ranges.map((r) => r.toString()).join(", ")}
`;
  }
  if (embed.join !== DEFAULT_JOIN) {
    ref += `join: ${JSON.stringify(embed.join)}
`;
  }
  if (embed.display !== DEFAULT_DISPLAY) {
    ref += `display: ${embed.display}
`;
  }
  if (embed.show.author || embed.show.title) {
    const show = [];
    if (embed.show.author) {
      show.push("author");
    }
    if (embed.show.title) {
      show.push("title");
    }
    ref += `show: ${show.join(", ")}
`;
  }
  ref += "```";
  return ref;
}
function parse(text) {
  const embedData = {
    file: "",
    subpath: "",
    ranges: [],
    join: DEFAULT_JOIN,
    show: {
      title: false,
      author: false
    },
    display: DEFAULT_DISPLAY
  };
  const settingRegex = /^(\w+):\s*(.+?)\s*$/gm;
  let matches;
  while ((matches = settingRegex.exec(text)) !== null) {
    const [, settingName, settingText] = matches;
    if (settingName in lineParsers) {
      lineParsers[settingName](settingText, embedData);
    }
  }
  return embedData;
}
var lineParsers = {
  path: (text, data) => {
    let match;
    if (match = text.match(/^\[\[([^#|[\]^]+)((#[^#]+)*)\]\]$/)) {
      data.file = match[1];
      data.subpath = match[2];
    } else {
      throw new Error("invalid path line");
    }
  },
  file: (text, data) => {
    if (/^\[\[.+?\]\]$/.test(text)) {
      data.file = text.slice(2, -2);
    } else {
      throw new Error("invalid file line");
    }
  },
  heading: (text, data) => {
    if (/^(#[^#]+)+$/.test(text)) {
      data.subpath += text;
    } else {
      throw new Error("invalid heading line");
    }
  },
  block: (text, data) => {
    if (/^\^\w+$/.test(text)) {
      data.subpath += "#" + text;
    } else {
      throw new Error("invalid block line");
    }
  },
  ranges: (text, data) => {
    const tokenRegex = /"([^"\\]|\\.)+"|\d+:\d+|to|after|,/g;
    data.ranges = [];
    const tokens = [];
    let matches;
    while ((matches = tokenRegex.exec(text)) !== null) {
      tokens.push(matches[0]);
    }
    while (tokens.length > 0) {
      data.ranges.push(parseRange(tokens));
      if (tokens.length > 0) {
        if (tokens[0] == ",") {
          tokens.shift();
        } else {
          throw new Error("range syntax error");
        }
      }
    }
  },
  join: (text, data) => {
    if (/^"([^"\\]|\\.)+"$/.test(text)) {
      data.join = JSON.parse(text);
    } else {
      throw new Error("invalid join line");
    }
  },
  show: (text, data) => {
    const showRegex = /(^|,)\s*([a-z]+)\s*/g;
    let matches;
    while ((matches = showRegex.exec(text)) !== null) {
      const toggle = matches[2];
      if (toggle in data.show) {
        data.show[toggle] = true;
      } else {
        throw new Error("invalid show option");
      }
    }
  },
  display: (text, data) => {
    if (/^embedded|inline$/.test(text)) {
      data.display = text;
    } else {
      throw new Error("invalid display line");
    }
  }
};
function parseRange(tokens) {
  const cur = tokens[0];
  if (cur === "after") {
    return parseAfterRange(tokens);
  } else if (cur[0] === '"') {
    return parseStringRange(tokens);
  } else {
    return parsePosRange(tokens);
  }
}
function parseAfterRange(tokens) {
  tokens.shift();
  if (tokens[0][0] === '"') {
    return new AfterString(JSON.parse(tokens.shift()));
  } else {
    return new AfterPos(parsePos(tokens.shift()));
  }
}
function parseStringRange(tokens) {
  const start = JSON.parse(tokens.shift());
  if (tokens.length === 0 || tokens[0] === ",") {
    return new WholeString(start);
  }
  if (tokens.shift() !== "to") {
    throw new Error("invalid ranges line");
  }
  const end = JSON.parse(tokens.shift());
  return new StringRange(start, end);
}
function parsePosRange(tokens) {
  const start = parsePos(tokens.shift());
  if (tokens.shift() !== "to") {
    throw new Error("invalid ranges line");
  }
  const end = parsePos(tokens.shift());
  return new PosRange(start, end);
}
function parsePos(token) {
  const parts = token.split(":");
  if (parts.length !== 2) {
    throw new Error("invalid ranges line");
  }
  const [line, ch] = parts.map((n) => parseInt(n));
  return { line, ch };
}

// src/util/obsidian/subpath.ts
function scopeSubpath(cache, range) {
  const block = getContainingBlock(cache.blocks, range);
  if (block) {
    return "#^" + block.id;
  }
  const headings = getParentHeadings(cache.headings, range);
  if (headings.length > 0) {
    if (!isUniquePath(cache.headings, headings)) {
      return "";
    }
    let uniqueLen = 1;
    while (!isUniquePath(cache.headings, headings.slice(-uniqueLen))) {
      uniqueLen += 1;
    }
    return "#" + headings.slice(-uniqueLen).map((h) => h.heading).join("#");
  }
  return "";
}
function getContainingBlock(blocks, range) {
  for (const k in blocks) {
    if (blocks[k].position.start.line <= range.from.line && blocks[k].position.end.line >= range.to.line) {
      return blocks[k];
    }
  }
  return null;
}
function getParentHeadings(headings, range) {
  if (!headings) {
    return [];
  }
  const lastHeadingIdx = indexOfLastHeading(headings, range.to.line);
  const parents = [];
  let level = Infinity;
  for (let i = lastHeadingIdx; i >= 0; i--) {
    if (headings[i].level < level) {
      level = headings[i].level;
      if (headings[i].position.start.line <= range.from.line) {
        parents.unshift(headings[i]);
      }
    }
  }
  return parents;
}
function isUniquePath(allHeadings, path) {
  let found = 0;
  let level = [];
  let pathIdx = 0;
  for (let i = 0; i < allHeadings.length; i++) {
    if (allHeadings[i].heading === path[pathIdx].heading) {
      if (pathIdx === path.length - 1) {
        found += 1;
        level = [];
        pathIdx = 0;
      } else {
        level.push(allHeadings[i].level);
        pathIdx += 1;
      }
    } else if (allHeadings[i].level <= level.last()) {
      pathIdx -= 1;
      level.pop();
    }
  }
  return found <= 1;
}
function indexOfLastHeading(headings, beforeLine) {
  let idx = -1;
  for (let i = 0; i < headings.length; i++) {
    if (headings[i].position.end.line > beforeLine) {
      break;
    }
    idx = i;
  }
  return idx;
}

// src/commands/buildEmbed.ts
function buildEmbed(app, settings, file, text, editorRange) {
  var _a;
  const selectedText = text.slice(posIndex(text, editorRange.from), posIndex(text, editorRange.to));
  const fileCache2 = app.metadataCache.getFileCache(file);
  const subpath = scopeSubpath(fileCache2, editorRange);
  if (subpath.length > 0) {
    const subpathResult = (0, import_obsidian2.resolveSubpath)(fileCache2, subpath);
    text = text.slice(subpathResult.start.offset, (_a = subpathResult.end) == null ? void 0 : _a.offset);
    editorRange.from.line -= subpathResult.start.line;
    editorRange.to.line -= subpathResult.start.line;
  }
  const range = getBestRange(text, selectedText, editorRange);
  const embed = {
    file: app.metadataCache.fileToLinktext(file, "/", true),
    subpath,
    ranges: [],
    join: DEFAULT_JOIN,
    show: __spreadValues({
      author: false,
      title: false
    }, settings.defaultShow),
    display: settings.defaultDisplay || DEFAULT_DISPLAY
  };
  if (range) {
    embed.ranges.push(range);
  }
  return serialize(embed);
}
function getBestRange(doc, selectedText, selectedRange) {
  if (doc === selectedText) {
    return null;
  }
  if (isUnique(doc, selectedText)) {
    const points = uniqueStrRange(doc, selectedText);
    if (points.length === 1) {
      return new WholeString(points[0]);
    } else {
      return new StringRange(points[0], points[1]);
    }
  } else {
    return new PosRange(selectedRange.from, selectedRange.to);
  }
}

// src/commands/copyButton.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/commands/selection.ts
var lastRange;
function getSelectedRange() {
  return lastRange;
}
function isTextSelected() {
  var _a;
  return !((_a = getSelectedRange()) == null ? void 0 : _a.collapsed);
}
function selectListener() {
  var _a;
  const sel = document.getSelection();
  if (sel.rangeCount > 0) {
    const range = document.getSelection().getRangeAt(0);
    const startEl = range.startContainer;
    if ((startEl == null ? void 0 : startEl.className) != "prompt" && !((startEl == null ? void 0 : startEl.tagName) == "BODY" && ((_a = startEl == null ? void 0 : startEl.className) == null ? void 0 : _a.indexOf("is-mobile")) >= 0)) {
      lastRange = range;
    }
  }
}

// src/commands/copyReference.ts
var import_obsidian3 = __toModule(require("obsidian"));

// src/util/escapeRegex.ts
function escapeRegex(re) {
  return re.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/commands/rangeRegex.ts
function rangeRegex(range) {
  return new RegExp(getRangePrefix(range) + getRangeText(range).join(".*?").trim().replace(/\s+/gm, "\\s+") + getRangeSuffix(range), "ms");
}
function getRangePrefix(range) {
  let prefix = "";
  if (range.startOffset === 0) {
    let node = range.startContainer;
    while (node.nodeType !== node.TEXT_NODE && node.firstChild) {
      node = node.firstChild;
    }
    while (node.isSameNode(node.parentNode.firstChild)) {
      if (node.parentNode.nodeType === Node.ELEMENT_NODE) {
        const matcher = prefixList.find((p) => node.parentNode.matches(p.matcher));
        if (matcher) {
          prefix = `((${matcher.regex})\\s*?)?` + prefix;
        }
      }
      if (node.isSameNode(range.commonAncestorContainer)) {
        break;
      }
      node = node.parentNode;
    }
    return prefix;
  } else {
    return "";
  }
}
function getRangeSuffix(range) {
  let suffix = "";
  let node = range.endContainer;
  if (node.nodeType === Node.TEXT_NODE && range.endOffset === node.textContent.length || node.nodeType === Node.ELEMENT_NODE && range.endOffset === node.childNodes.length) {
    while (node.nodeType !== node.TEXT_NODE && node.lastChild) {
      node = node.lastChild;
    }
    while (node.isSameNode(node.parentNode.lastChild)) {
      if (node.parentNode.nodeType === node.ELEMENT_NODE) {
        const matcher = suffixList.find((p) => node.parentNode.matches(p.matcher));
        if (matcher) {
          suffix += `(\\s*?(${matcher.regex}))?`;
        }
      }
      if (node.isSameNode(range.commonAncestorContainer)) {
        break;
      }
      node = node.parentNode;
    }
    return suffix;
  } else {
    return "";
  }
}
var prefixList = [
  { matcher: "h1", regex: "#" },
  { matcher: "h2", regex: "##" },
  { matcher: "h3", regex: "###" },
  { matcher: "h4", regex: "####" },
  { matcher: "h5", regex: "#####" },
  { matcher: "h6", regex: "######" },
  { matcher: "blockquote", regex: ">" },
  { matcher: "strong", regex: "\\*\\*|__" },
  { matcher: "em", regex: "[*_]" },
  { matcher: "del", regex: "~~" },
  { matcher: "mark", regex: "==" },
  { matcher: "ul > li", regex: "[+*-]" },
  { matcher: "ol > li", regex: "\\d+[.)]" },
  { matcher: "pre > code", regex: "`{3,}|~{3,}|\\t| {4}" },
  { matcher: "code", regex: "`" },
  { matcher: "a.internal-link", regex: "\\[\\[(.+?\\|)?" },
  { matcher: "a", regex: "\\[|<" }
];
var suffixList = [
  { matcher: "strong", regex: "\\*\\*|__" },
  { matcher: "em", regex: "[*_]" },
  { matcher: "del", regex: "~~" },
  { matcher: "mark", regex: "==" },
  { matcher: "code", regex: "`" },
  { matcher: "a.internal-link", regex: "\\]\\]" },
  { matcher: "a", regex: "\\]|>" }
];
var appendList = [
  { matcher: ".copy-code-button", fn: nop },
  { matcher: ".collapse-indicator", fn: nop },
  { matcher: ".markdown-preview-pusher", fn: nop },
  { matcher: ".internal-embed", fn: appendEmbed },
  { matcher: "img", fn: appendImg },
  { matcher: ".footnote-ref", fn: appendFootnote },
  { matcher: "iframe", fn: appendIframe },
  { matcher: "*", fn: appendChildren }
];
function getRangeText(range) {
  const text = [];
  walkRange(range, (n) => {
    appendNode(text, n, range);
  });
  return text;
}
function walkRange(range, fn) {
  let node = range.startContainer;
  while (!node.isSameNode(range.endContainer)) {
    if (node.contains(range.endContainer)) {
      node = node.firstChild;
    } else {
      fn(node);
      while (!node.nextSibling) {
        node = node.parentNode;
      }
      node = node.nextSibling;
    }
  }
  fn(range.endContainer);
}
function appendNode(text, node, range) {
  if (node.nodeType === Node.TEXT_NODE) {
    appendTextNode(text, node, range);
  } else if (node.nodeType === Node.ELEMENT_NODE) {
    appendEl(text, node, range);
  }
}
function appendEl(text, el, range) {
  const fn = appendList.find((m) => el.matches(m.matcher)).fn;
  fn(text, el, range);
}
function appendEmbed(text, el) {
  text.push(`!\\[\\[${el.getAttribute("src")}\\]\\]`);
}
function appendImg(text, el) {
  let img = "!\\[";
  if (el.hasAttribute("alt")) {
    img += el.getAttribute("alt");
  }
  img += "\\]\\(" + el.getAttribute("src");
  if (el.hasAttribute("title")) {
    img += ` "${el.getAttribute("title")}"`;
  }
  img += "\\)";
  text.push(img);
}
function appendFootnote(text) {
  text.push("\\[\\^[^\\]]*\\]");
}
function appendIframe(text, el) {
  text.push(`<iframe[^>]+src="${el.getAttribute("src")}"[^>]*></iframe>`);
}
function appendChildren(text, el, range) {
  let startOffset = 0, endOffset = el.childNodes.length;
  if (el.isSameNode(range.startContainer)) {
    startOffset = range.startOffset;
  }
  if (el.isSameNode(range.endContainer)) {
    endOffset = range.endOffset;
  }
  for (let i = startOffset; i < endOffset; i++) {
    appendNode(text, el.childNodes[i], range);
  }
}
function nop() {
}
function appendTextNode(text, node, range) {
  let startOffset = 0, endOffset = node.textContent.length;
  if (node.isSameNode(range.startContainer)) {
    startOffset = range.startOffset;
  }
  if (node.isSameNode(range.endContainer)) {
    endOffset = range.endOffset;
  }
  text.push(escapeRegex(node.textContent.slice(startOffset, endOffset)));
}

// src/commands/copyReference.ts
function checkCopyReference(app, settings, checking) {
  const view = app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
  if (!checking && view) {
    try {
      navigator.clipboard.writeText(buildEmbed(app, settings, view.file, view.editor.getValue(), getViewRange(view, view.editor)));
      new import_obsidian3.Notice("Reference copied!", 1500);
    } catch (e) {
      new import_obsidian3.Notice(e, 3e3);
    }
  }
  return (view == null ? void 0 : view.getMode()) === "source" && view.editor.somethingSelected() || (view == null ? void 0 : view.getMode()) === "preview" && isTextSelected();
}
function getViewRange(view, editor) {
  if (view.getMode() === "source") {
    return getSourceRange(editor);
  } else {
    return getPreviewRange(editor);
  }
}
function getSourceRange(editor) {
  if (!editor.somethingSelected()) {
    throw new Error("Nothing is selected");
  }
  return selectionToRange(editor.listSelections()[0]);
}
function getPreviewRange(editor) {
  if (!isTextSelected()) {
    throw new Error("Nothing is selected");
  }
  const selectedRegex = rangeRegex(getSelectedRange());
  const match = editor.getValue().match(selectedRegex);
  if (!match) {
    throw new Error("Unable to locate markdown from preview, try copying from source mode.");
  }
  return {
    from: editor.offsetToPos(match.index),
    to: editor.offsetToPos(match.index + match[0].length)
  };
}
function selectionToRange(sel) {
  let start = sel.anchor;
  let end = sel.head;
  if (start.line > end.line || start.line == end.line && start.ch > end.ch) {
    [start, end] = [end, start];
  }
  return { from: start, to: end };
}

// src/commands/copyButton.ts
function copyButton(app, settings) {
  if (!settings.showMobileButton) {
    return;
  }
  const view = app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
  if ((view == null ? void 0 : view.getMode()) === "preview" && isTextSelected()) {
    if (!view.previewMode.containerEl.querySelector(".quoth-copy-button")) {
      const button = view.previewMode.containerEl.createDiv("quoth-copy-button");
      (0, import_obsidian4.setIcon)(button, "quoth-copy", 30);
      button.addEventListener("click", () => {
        checkCopyReference(app, settings, false);
        button.remove();
      });
    }
  } else if ((view == null ? void 0 : view.getMode()) === "preview") {
    view.previewMode.containerEl.querySelectorAll(".quoth-copy-button").forEach((b) => b.remove());
  }
}

// src/processors/processor.ts
var import_obsidian6 = __toModule(require("obsidian"));

// src/processors/markdown.ts
var BlockQuoteToken = {
  type: "linestart",
  matcher: ">( |\\t)?"
};
var HeadingToken = {
  type: "linestart",
  matcher: "#{1,6}( |\\t)"
};
var ListItemToken = {
  type: "linestart",
  matcher: "(( |	)*(\\d+[.)])|[+*-])( |\\t)"
};
var CodeLineToken = {
  type: "linestart",
  matcher: " {4}|\\t"
};
var StrongToken = {
  type: "surrounding",
  matcher: "\\*\\*|__"
};
var StrikeToken = { type: "surrounding", matcher: "~~" };
var MarkToken = { type: "surrounding", matcher: "==" };
var EmToken = { type: "surrounding", matcher: "[*_]" };
var CodeToken = { type: "surrounding", matcher: "`" };
var TextToken = { type: "text", matcher: "." };
var tokenList = [
  BlockQuoteToken,
  HeadingToken,
  ListItemToken,
  CodeLineToken,
  StrongToken,
  StrikeToken,
  MarkToken,
  EmToken,
  CodeToken,
  TextToken
];
function extractRangeWithContext(text, range) {
  const { start, end } = range.indexes(text);
  return markdownPrefix(text, start) + text.slice(start, end) + markdownSuffix(text, end);
}
function markdownPrefix(text, start) {
  const startLine = text.slice(text.lastIndexOf("\n", start) + 1, start);
  const tokens = tokenize(startLine);
  return joinTokens(startTokens(tokens).concat(openTokens(tokens)));
}
function markdownSuffix(text, end) {
  const endLine = text.slice(text.lastIndexOf("\n", end) + 1, end);
  return joinTokens(openTokens(tokenize(endLine)).reverse());
}
function normalizeMarkdown(text) {
  let parts = text.split("\n");
  while (parts[0].length > 0) {
    while (all(parts, (p) => /^ |\t/.test(p))) {
      parts = parts.map((p) => p.slice(1));
    }
    if (all(parts, (p) => startsWithToken(p, BlockQuoteToken))) {
      parts = parts.map((p) => sliceToken(p, BlockQuoteToken)[0]);
    } else {
      break;
    }
  }
  if (parts.length === 1) {
    if (startsWithToken(parts[0], ListItemToken)) {
      parts[0] = sliceToken(parts[0], ListItemToken)[0];
    }
    if (startsWithToken(parts[0], HeadingToken)) {
      parts[0] = sliceToken(parts[0], HeadingToken)[0];
    }
  }
  return parts.join("\n");
}
function startTokens(tokens) {
  return tokens.filter((t) => t.token.type === "linestart");
}
function openTokens(tokens) {
  const open = [];
  tokens.filter((t) => t.token.type === "surrounding").forEach((t) => {
    var _a;
    if (((_a = open.last()) == null ? void 0 : _a.text) === t.text) {
      open.pop();
    } else {
      open.push(t);
    }
  });
  return open;
}
function tokenize(str) {
  var _a;
  let matchLineStart = true;
  let matchers = tokenList;
  const tokens = [];
  while (str.length > 0) {
    const token = matchers.find((t) => startsWithToken(str, t));
    let match;
    [str, match] = sliceToken(str, token);
    if (token === TextToken && ((_a = tokens.last()) == null ? void 0 : _a.token) === TextToken) {
      tokens.last().text += match;
    } else {
      tokens.push({ token, text: match });
    }
    if (token.type !== "linestart" && matchLineStart) {
      matchLineStart = false;
      matchers = matchers.filter((m) => m.type !== "linestart");
    }
  }
  return tokens;
}
function all(array, f) {
  return array.filter(f).length === array.length;
}
function startsWithToken(text, token) {
  return new RegExp("^" + token.matcher).test(text);
}
function sliceToken(text, token) {
  const match = text.match(new RegExp("^" + token.matcher));
  return [text.slice(match[0].length), match[0]];
}
function joinTokens(tokens) {
  return tokens.map((t) => t.text).join("");
}

// src/processors/languageMap.ts
var languageMap = {
  "1": "troff",
  "2": "troff",
  "3": "troff",
  "4": "troff",
  "5": "troff",
  "6": "troff",
  "7": "troff",
  "8": "troff",
  "9": "troff",
  dyalog: "apl",
  apl: "apl",
  asc: "asciiarmor",
  pgp: "asciiarmor",
  sig: "mllike",
  asn: "asn.1",
  asn1: "asn.1",
  b: "brainfuck",
  bf: "brainfuck",
  c: "clike",
  h: "clike",
  ino: "clike",
  cpp: "clike",
  "c++": "clike",
  cc: "clike",
  cxx: "clike",
  hpp: "clike",
  "h++": "clike",
  hh: "clike",
  hxx: "clike",
  cob: "cobol",
  cpy: "cobol",
  cbl: "cobol",
  cs: "clike",
  clj: "clojure",
  cljc: "clojure",
  cljx: "clojure",
  cljs: "clojure",
  gss: "css",
  cmake: "cmake",
  "cmake.in": "cmake",
  coffee: "coffeescript",
  cl: "commonlisp",
  lisp: "commonlisp",
  el: "commonlisp",
  cyp: "cypher",
  cypher: "cypher",
  pyx: "python",
  pxd: "python",
  pxi: "python",
  cr: "crystal",
  css: "css",
  cql: "sql",
  d: "d",
  dart: "dart",
  diff: "diff",
  patch: "diff",
  dtd: "dtd",
  dylan: "dylan",
  dyl: "dylan",
  intr: "dylan",
  ecl: "ecl",
  edn: "clojure",
  e: "eiffel",
  elm: "elm",
  ejs: "htmlembedded",
  erb: "htmlembedded",
  erl: "erlang",
  factor: "factor",
  forth: "forth",
  fth: "forth",
  "4th": "forth",
  f: "fortran",
  for: "fortran",
  f77: "fortran",
  f90: "fortran",
  f95: "fortran",
  fs: "mllike",
  s: "gas",
  feature: "gherkin",
  go: "go",
  groovy: "groovy",
  gradle: "groovy",
  haml: "haml",
  hs: "haskell",
  lhs: "haskell-literate",
  hx: "haxe",
  hxml: "haxe",
  aspx: "htmlembedded",
  html: "htmlmixed",
  htm: "htmlmixed",
  handlebars: "htmlmixed",
  hbs: "htmlmixed",
  pro: "idl",
  jade: "pug",
  pug: "pug",
  java: "clike",
  jsp: "htmlembedded",
  js: "javascript",
  json: "javascript",
  map: "javascript",
  jsonld: "pegjs",
  jsx: "jsx",
  j2: "jinja2",
  jinja: "jinja2",
  jinja2: "jinja2",
  jl: "julia",
  kt: "clike",
  less: "css",
  ls: "livescript",
  lua: "lua",
  markdown: "markdown",
  md: "markdown",
  mkd: "markdown",
  m: "octave",
  nb: "mathematica",
  wl: "mathematica",
  wls: "mathematica",
  mo: "modelica",
  mps: "mumps",
  mbox: "mbox",
  nsh: "nsis",
  nsi: "nsis",
  nt: "ntriples",
  nq: "ntriples",
  mm: "clike",
  ml: "mllike",
  mli: "mllike",
  mll: "mllike",
  mly: "mllike",
  oz: "oz",
  p: "pascal",
  pas: "pascal",
  pl: "perl",
  pm: "perl",
  php: "php",
  php3: "php",
  php4: "php",
  php5: "php",
  php7: "php",
  phtml: "php",
  pig: "pig",
  txt: "null",
  text: "stex",
  conf: "null",
  def: "null",
  list: "null",
  log: "null",
  pls: "sql",
  ps1: "powershell",
  psd1: "powershell",
  psm1: "powershell",
  properties: "properties",
  ini: "properties",
  in: "properties",
  proto: "protobuf",
  BUILD: "python",
  bzl: "python",
  py: "python",
  pyw: "python",
  pp: "puppet",
  q: "q",
  r: "r",
  R: "r",
  rst: "rst",
  spec: "rpm",
  rb: "ruby",
  rs: "rust",
  sas: "sas",
  sass: "sass",
  scala: "clike",
  scm: "scheme",
  ss: "scheme",
  scss: "css",
  sh: "shell",
  ksh: "shell",
  bash: "shell",
  siv: "sieve",
  sieve: "sieve",
  slim: "slim",
  st: "smalltalk",
  tpl: "smarty",
  sml: "mllike",
  fun: "mllike",
  smackspec: "mllike",
  soy: "soy",
  rq: "sparql",
  sparql: "sparql",
  sql: "sql",
  nut: "clike",
  styl: "stylus",
  swift: "swift",
  ltx: "stex",
  tex: "stex",
  v: "verilog",
  sv: "verilog",
  svh: "verilog",
  tcl: "tcl",
  textile: "textile",
  toml: "toml",
  ttcn: "ttcn",
  ttcn3: "ttcn",
  ttcnpp: "ttcn",
  cfg: "ttcn-cfg",
  ttl: "turtle",
  ts: "javascript",
  tsx: "jsx",
  webidl: "webidl",
  vb: "vb",
  vbs: "vbscript",
  vtl: "velocity",
  vhd: "vhdl",
  vhdl: "vhdl",
  vue: "vue",
  xml: "xml",
  xsl: "xml",
  xsd: "xml",
  svg: "xml",
  xy: "xquery",
  xquery: "xquery",
  ys: "yacas",
  yaml: "yaml",
  yml: "yaml",
  z80: "z80",
  mscgen: "mscgen",
  mscin: "mscgen",
  msc: "mscgen",
  xu: "mscgen",
  msgenny: "mscgen",
  wat: "wast",
  wast: "wast"
};

// src/util/obsidian/resolveSubpath.ts
var import_obsidian5 = __toModule(require("obsidian"));

// src/util/obsidian/resolveList.ts
function resolveList(doc, listItems, subpath) {
  const itemPath = subpath.split("#-").slice(1).reverse();
  const listItem = listItems == null ? void 0 : listItems.find((li) => listMatches(li, doc, itemPath[0]) && hasAncestors(doc, listItems, li, itemPath.slice(1)));
  if (!listItem) {
    return null;
  }
  return {
    type: "list-item",
    listItem,
    children: listChildren(listItems, listItem),
    start: listItem.position.start,
    end: maxEnd(listItems, listItem)
  };
}
function listMatches(li, doc, text) {
  const regex = new RegExp("^(\\d+[.)]|[+*-])\\s+" + escapeRegex(text) + "$", "");
  return regex.test(doc.slice(li.position.start.offset, li.position.end.offset));
}
function hasAncestors(doc, listItems, li, parents) {
  if (parents.length == 0) {
    return true;
  }
  while ((li = listItems.find((p) => p.position.start.line === li.parent)) != null) {
    if (listMatches(li, doc, parents[0])) {
      return hasAncestors(doc, listItems, li, parents.slice(1));
    }
  }
  return false;
}
function maxEnd(listItems, parent) {
  let end = parent.position.end;
  let children = listChildren(listItems, parent);
  while (children.length > 0) {
    const last = children.sort((a, b) => a.position.end.offset - b.position.end.offset).last();
    if (last.position.end.offset > end.offset) {
      end = last.position.end;
    }
    children = listChildren(listItems, last);
  }
  return end;
}
function listChildren(listItems, parent) {
  return listItems.filter((li) => li.parent == parent.position.start.line);
}

// src/util/obsidian/resolveSubpath.ts
function resolveSubpath2(doc, fileCache2, subpath) {
  const listIndex = subpath.indexOf("#-");
  if (listIndex >= 0) {
    let listItems = fileCache2.listItems || [];
    if (listIndex > 0) {
      const result2 = (0, import_obsidian5.resolveSubpath)(fileCache2, subpath.slice(0, listIndex));
      if (!result2) {
        return null;
      }
      listItems = listItems.filter((li) => {
        var _a;
        return li.position.start.offset >= result2.start.offset && li.position.end.offset <= (((_a = result2.end) == null ? void 0 : _a.offset) || doc.length);
      });
    }
    const result = resolveList(doc, listItems, subpath.slice(listIndex));
    if (result) {
      return result;
    }
  }
  return (0, import_obsidian5.resolveSubpath)(fileCache2, subpath);
}

// src/processors/processor.ts
function quothProcessor(app, source, el, ctx) {
  return __async(this, null, function* () {
    try {
      const embed = parse(source);
      const quote = yield assembleQuote(app, ctx.sourcePath, embed);
      renderQuote(app, el, ctx.sourcePath, quote, embed.display, embed.show);
    } catch (e) {
      renderError(el, e);
    }
  });
}
function assembleQuote(app, source, embed) {
  return __async(this, null, function* () {
    var _a;
    if (embed.file === "") {
      throw new Error("File must be set in block");
    }
    const file = app.metadataCache.getFirstLinkpathDest(embed.file, source);
    if (!file) {
      throw new Error(`File not found: ${embed.file}`);
    }
    const fileCache2 = app.metadataCache.getFileCache(file);
    const text = quoteContent(yield app.vault.cachedRead(file), fileCache2, embed.subpath);
    let quote;
    if (embed.ranges.length > 0) {
      if (file.extension.toLowerCase() == "md") {
        quote = embed.ranges.map((r) => extractRangeWithContext(text, r)).join(embed.join);
      } else {
        quote = embed.ranges.map((r) => {
          const { start, end } = r.indexes(text);
          return text.slice(start, end);
        }).join(embed.join);
      }
    } else {
      quote = text;
    }
    if (file.extension.toLowerCase() == "md") {
      quote = normalizeMarkdown(quote);
    } else {
      const language = languageMap[file.extension.toLowerCase()] || "";
      quote = "```" + language + "\n" + quote.replace(/^\n+|\n+$/, "") + "\n```";
    }
    return {
      file,
      subpath: embed.subpath,
      markdown: quote,
      title: file.basename,
      author: (_a = fileCache2 == null ? void 0 : fileCache2.frontmatter) == null ? void 0 : _a.author
    };
  });
}
function quoteContent(data, cache, subpath) {
  var _a;
  if (subpath) {
    const pathResult = resolveSubpath2(data, cache, subpath);
    if (pathResult) {
      return data.slice(pathResult.start.offset, (_a = pathResult.end) == null ? void 0 : _a.offset);
    } else {
      throw new Error(`subpath not found: ${subpath}`);
    }
  }
  return data;
}
function renderQuote(app, el, source, quote, display, show) {
  if (display == "embedded") {
    el = createEmbedWrapper(el, source, quote, (p, s, n) => app.workspace.openLinkText(p, s, n));
  }
  if (quote.markdown.includes("```quoth")) {
    throw new Error("Can not quote a quoth code block.");
  }
  import_obsidian6.MarkdownRenderer.renderMarkdown(quote.markdown, el, source, null);
  renderOptions(el, app, source, show, quote);
}
function createEmbedWrapper(el, sourcePath, quote, openLink) {
  const path = quote.title + quote.subpath;
  const span = el.createSpan({
    cls: "internal-embed",
    attr: {
      alt: path.replace(/#/g, " ^ "),
      src: path
    }
  });
  const mdEmbed = span.createDiv({ cls: "markdown-embed" });
  const mdEmbedCont = mdEmbed.createDiv({ cls: "markdown-embed-content" });
  const mdPrev = mdEmbedCont.createDiv({ cls: "quoth-embedded-view" });
  const mdPrevSec = mdPrev.createDiv({
    cls: "markdown-preview-sizer markdown-preview-section",
    attr: {
      style: "padding-bottom: 0px"
    }
  });
  mdPrevSec.createDiv({
    cls: "markdown-preview-pusher",
    attr: {
      style: "width: 1px; height: 0.1px; margin-bottom: 0px;"
    }
  });
  const mdLink = mdEmbed.createDiv({
    cls: "markdown-embed-link",
    attr: { "aria-label": "Open Link" }
  });
  (0, import_obsidian6.setIcon)(mdLink, "link", 20);
  mdLink.addEventListener("click", (e) => __async(this, null, function* () {
    if (e.button === 0) {
      yield openLink(quote.file.name + quote.subpath, sourcePath, import_obsidian6.Keymap.isModEvent(e));
    }
  }));
  return mdPrevSec.createDiv();
}
function renderOptions(el, app, sourcePath, show, quote) {
  if (!(show.author && quote.author) && !show.title) {
    return;
  }
  const source = el.createDiv({ cls: "quoth-source" });
  if (show.author && quote.author) {
    source.createSpan({ cls: "quoth-author", text: quote.author });
  }
  if (show.title) {
    const path = app.metadataCache.fileToLinktext(quote.file, sourcePath);
    const title = source.createSpan({ cls: "quoth-title" });
    title.createEl("a", {
      cls: "internal-link",
      href: path,
      text: quote.title,
      attr: {
        target: "_blank",
        "data-href": path,
        rel: "noopener"
      }
    });
  }
}
function renderError(el, error) {
  el.createEl("strong", { text: `Quoth block error: ${error.message}` });
}

// src/commands/replaceBlockquotes.ts
var import_obsidian7 = __toModule(require("obsidian"));
function replaceBlockquotes(app, settings, editor) {
  return __async(this, null, function* () {
    const modal = new FileSuggester(app, (sourceFile) => __async(this, null, function* () {
      let doc = editor.getValue();
      const matcher = /(?:(?:^|\n)>[^\n]+)+/gm;
      const sourceDoc = yield app.vault.cachedRead(sourceFile);
      let replaced = 0;
      doc = doc.replace(matcher, (match) => {
        const sourceMatcher = new RegExp(escapeRegex(match.replace(/(^|\n)>/g, "$1")).trim().replace(/\s+/g, "\\s*"), "m");
        const sourceMatch = sourceDoc.match(sourceMatcher);
        if (sourceMatch) {
          replaced += 1;
          return "\n" + buildEmbed(app, settings, sourceFile, sourceDoc, {
            from: indexPos(sourceDoc, sourceMatch.index),
            to: indexPos(sourceDoc, sourceMatch.index + sourceMatch[0].length)
          });
        }
        return match;
      });
      if (replaced > 0) {
        editor.setValue(doc);
        new import_obsidian7.Notice(`Replaced ${replaced} blockquote${replaced > 1 ? "s" : ""} with quoth embeds from ${sourceFile.basename}`, 3e3);
      } else {
        new import_obsidian7.Notice(`Unable to locate any quotes to replace in ${sourceFile.basename}`, 3e3);
      }
    }));
    modal.open();
  });
}
var FileSuggester = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app, cb) {
    super(app);
    this.app = app;
    this.cb = cb;
    this.setPlaceholder("Type source filename...");
  }
  getItems() {
    return this.app.vault.getMarkdownFiles();
  }
  getItemText(item) {
    return item.basename;
  }
  onChooseItem(item) {
    this.cb(item);
  }
};

// src/settings.ts
var import_obsidian9 = __toModule(require("obsidian"));

// src/model/embedCache.ts
var import_obsidian8 = __toModule(require("obsidian"));
var IndexListener = class {
  constructor(app, load, save) {
    this.app = app;
    this.load = load;
    this.save = save;
  }
  rename(file, oldPath) {
    return __async(this, null, function* () {
      let refs = this.load();
      if (file instanceof import_obsidian8.TFile && isFileInCache(refs, oldPath)) {
        refs = renameFile(refs, file, oldPath);
        yield this.save(refs);
        const dirtyRefs = dirtyEmbeds(refs, file);
        yield updateQuothPathInFiles(dirtyRefs, this.app, file, oldPath);
      }
    });
  }
  delete(file) {
    return __async(this, null, function* () {
      const refs = this.load();
      if (file instanceof import_obsidian8.TFile && isFileInCache(refs, file.path)) {
        yield this.save(filterOutFile(refs, file));
      }
    });
  }
  modify(file) {
    return __async(this, null, function* () {
      const embeds = this.load();
      if (file instanceof import_obsidian8.TFile) {
        const filtered = filterOutFile(embeds, file);
        const fileEmbeds = yield fileCache(file, this.app);
        if (filtered.length !== embeds.length || fileEmbeds.length > 0) {
          this.save([...filtered, ...fileEmbeds]);
        }
      }
    });
  }
};
function isFileInCache(cache, path) {
  return cache.find((e) => e.refFile === path || e.sourceFile === path) !== void 0;
}
function filterOutFile(cache, file) {
  return cache.filter((e) => e.refFile !== file.path);
}
function buildIndex(app) {
  return __async(this, null, function* () {
    const mdFiles = app.vault.getMarkdownFiles();
    return (yield Promise.all(mdFiles.map((file) => __async(this, null, function* () {
      return yield fileCache(file, this.app);
    })))).flat();
  });
}
function fileCache(file, app) {
  return __async(this, null, function* () {
    const fileEmbeds = [];
    const fileData = yield app.vault.cachedRead(file);
    quothOffsets(fileData).forEach((offset, idx) => {
      const embed = parse(fileData.slice(offset.start, offset.end));
      const sourceFile = this.app.metadataCache.getFirstLinkpathDest(embed.file, file.path);
      if (sourceFile) {
        fileEmbeds.push({
          sourceFile: sourceFile.path,
          subPath: embed.subpath,
          ranges: embed.ranges.map((r) => r.toString()),
          refFile: file.path,
          refIdx: idx
        });
      }
    });
    return fileEmbeds;
  });
}
function renameFile(embeds, sourceFile, oldPath) {
  return embeds.map((embed) => {
    if (embed.sourceFile === oldPath) {
      embed = __spreadProps(__spreadValues({}, embed), { sourceFile: sourceFile.path });
    }
    if (embed.refFile === oldPath) {
      embed = __spreadProps(__spreadValues({}, embed), { refFile: sourceFile.path });
    }
    return embed;
  });
}
function dirtyEmbeds(refs, sourceFile) {
  const cacheByFile = {};
  refs.filter((e) => e.sourceFile === sourceFile.path).forEach((e) => {
    var _a;
    cacheByFile[_a = e.refFile] || (cacheByFile[_a] = []);
    cacheByFile[e.refFile].push(e);
  });
  return cacheByFile;
}
function updateQuothPathInFiles(cacheByFile, app, sourceFile, oldPath) {
  return __async(this, null, function* () {
    yield Promise.all(map(cacheByFile, (refPath, cache) => __async(this, null, function* () {
      const refFile = app.vault.getAbstractFileByPath(refPath);
      let refData = yield safeReadFile(app, refFile, oldPath);
      const offsets = quothOffsets(refData);
      cache.sort((a, b) => b.refIdx - a.refIdx);
      cache.forEach((embedCache) => {
        const { start, end } = offsets[embedCache.refIdx];
        const embed = parse(refData.slice(start, end));
        embed.file = app.metadataCache.fileToLinktext(sourceFile, refPath);
        refData = refData.slice(0, start) + serialize(embed) + refData.slice(end);
      });
      yield app.vault.modify(refFile, refData);
    })));
  });
}
function quothOffsets(fileData) {
  const startRegex = /^ {0,3}(?:`{3,}|~{3,})quoth/gm;
  const endRegex = /^ {0,3}(?:`{3,}|~{3,}) *$/gm;
  const offsets = [];
  let res;
  while (res = startRegex.exec(fileData)) {
    const start = res.index;
    endRegex.lastIndex = start;
    if (res = endRegex.exec(fileData)) {
      const end = res.index + res[0].length;
      startRegex.lastIndex = end;
      offsets.push({ start, end });
    }
  }
  return offsets;
}
var CHECK_SAFE_ATTEMPTS = 10;
var CHECK_SAFE_WAIT = 50;
function safeReadFile(app, file, oldPath) {
  return __async(this, null, function* () {
    let fileData;
    for (let i = 0; i < CHECK_SAFE_ATTEMPTS; i++) {
      fileData = yield app.vault.cachedRead(file);
      if (!anyStaleLinks(oldPath, fileData)) {
        break;
      }
      yield new Promise((resolve) => setTimeout(resolve, CHECK_SAFE_WAIT * (i + 1)));
    }
    return fileData;
  });
}
function anyStaleLinks(oldPath, fileData) {
  const quothMatcher = "(?:^|\\n) {0,3}(?:`{3,}|~{3,})quoth.+?\\n {0,3}(?:`{3,}|~{3,}) *(?:$|\\n)";
  const linkMatcher = "(\\[\\[(?:" + fileRegex(oldPath) + ")(?:\\|[^\\]|]+)?\\]\\])";
  const regex = new RegExp(quothMatcher + "|" + linkMatcher, "gs");
  let match;
  while (match = regex.exec(fileData)) {
    if (match[1] !== void 0) {
      return true;
    }
  }
  return false;
}
function fileRegex(path) {
  let prefix = "";
  path = escapeRegex("/" + path).replace(/.*?\//g, (match) => {
    prefix += "(?:";
    return match + ")?";
  }).replace(/(\\\.\w+)+$/, "(?:$&)?");
  return prefix + path;
}
function map(refsByFile, fn) {
  const results = [];
  for (const file in refsByFile) {
    results.push(fn(file, refsByFile[file]));
  }
  return results;
}

// src/settings.ts
var QuothSettingTab = class extends import_obsidian9.PluginSettingTab {
  constructor(plugin, data, saveSettings) {
    super(plugin.app, plugin);
    this.data = data;
    this.saveSettings = saveSettings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Quoth Settings" });
    new import_obsidian9.Setting(containerEl).setName("Rebuild Quoth Index").setDesc("This will load all quoths in your vault into the index. This may need to be called after a major update, or after updating markdown files outside of obsidian.").addButton((button) => {
      button.setButtonText("Rebuild Index").setClass("mod-cta").onClick(() => __async(this, null, function* () {
        if (button.disabled) {
          return;
        }
        button.setDisabled(true);
        button.setButtonText("Rebuilding Index...");
        this.data.index = yield buildIndex(this.app);
        yield this.saveSettings();
        button.setDisabled(false);
        button.setButtonText("Rebuild Index");
      }));
    });
    if (import_obsidian9.Platform.isMobile) {
      new import_obsidian9.Setting(containerEl).setName("Show Copy Button").setDesc("Mobile only. When a selection is made in preview mode, a button to copy will appear in the bottom right.").addToggle((toggle) => {
        toggle.setValue(this.data.copySettings.showMobileButton).onChange((value) => __async(this, null, function* () {
          this.data.copySettings.showMobileButton = value;
          yield this.saveSettings();
        }));
      });
    }
    containerEl.createEl("h4", {
      text: "Default copy reference options"
    });
    containerEl.createEl("p", {
      text: "Note: this changes only references copied going forward, not previous references."
    });
    new import_obsidian9.Setting(containerEl).setName("Display Style:").addDropdown((drop) => drop.addOptions({ null: "", embedded: "Embedded", inline: "Inline" }).setValue(this.data.copySettings.defaultDisplay).onChange((value) => __async(this, null, function* () {
      if (value == "null") {
        delete this.data.copySettings.defaultDisplay;
      } else {
        this.data.copySettings.defaultDisplay = value;
      }
      yield this.saveSettings();
    })));
    new import_obsidian9.Setting(containerEl).setName("Show Author:").addToggle((toggle) => toggle.setValue(this.data.copySettings.defaultShow.author).onChange((value) => __async(this, null, function* () {
      this.data.copySettings.defaultShow.author = value;
      yield this.saveSettings();
    })));
    new import_obsidian9.Setting(containerEl).setName("Show Title:").addToggle((toggle) => toggle.setValue(this.data.copySettings.defaultShow.title).onChange((value) => __async(this, null, function* () {
      this.data.copySettings.defaultShow.title = value;
      yield this.saveSettings();
    })));
  }
};

// src/main.ts
var DEFAULT_DATA = {
  copySettings: {
    defaultShow: {
      title: false,
      author: false
    },
    showMobileButton: false
  },
  index: []
};
var QuothPlugin = class extends import_obsidian10.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadStorage();
      addIcons();
      this.addSettingTab(new QuothSettingTab(this, this.data, () => __async(this, null, function* () {
        yield this.saveStorage();
      })));
      this.registerMarkdownCodeBlockProcessor("quoth", quothProcessor.bind(null, this.app));
      this.addCommand({
        id: "quoth-copy-reference",
        name: "Copy Reference",
        checkCallback: checkCopyReference.bind(null, this.app, this.data.copySettings),
        hotkeys: [
          {
            modifiers: ["Shift", "Mod"],
            key: "'"
          }
        ],
        icon: "quoth-copy"
      });
      this.addCommand({
        id: "quoth-replace-blockquotes",
        name: "Replace Blockquotes with Quoth Embeds",
        editorCallback: replaceBlockquotes.bind(null, this.app, this.data.copySettings)
      });
      this.registerDomEvent(document, "selectionchange", selectListener);
      if (import_obsidian10.Platform.isMobile) {
        this.registerDomEvent(document, "selectionchange", copyButton.bind(null, this.app, this.data.copySettings));
      }
      const indexListener = new IndexListener(this.app, () => this.data.index, (refs) => __async(this, null, function* () {
        this.data.index = refs;
        yield this.saveStorage();
      }));
      this.registerEvent(this.app.vault.on("rename", indexListener.rename.bind(indexListener)));
      this.registerEvent(this.app.vault.on("delete", indexListener.delete.bind(indexListener)));
      this.registerEvent(this.app.vault.on("modify", indexListener.modify.bind(indexListener)));
    });
  }
  loadStorage() {
    return __async(this, null, function* () {
      var _a;
      const loaded = yield this.loadData();
      this.data = __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_DATA), loaded), {
        copySettings: __spreadProps(__spreadValues(__spreadValues({}, DEFAULT_DATA.copySettings), loaded == null ? void 0 : loaded.copySettings), {
          defaultShow: __spreadValues(__spreadValues({}, DEFAULT_DATA.copySettings.defaultShow), (_a = loaded == null ? void 0 : loaded.copySettings) == null ? void 0 : _a.defaultShow)
        })
      });
    });
  }
  saveStorage() {
    return __async(this, null, function* () {
      yield this.saveData(this.data);
    });
  }
};
